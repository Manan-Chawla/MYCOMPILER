#include<iostream>
#include<stdlib.h>
using namespace std;   // if you run this in dev c++ it will run successfully as is not running becz
                       // there are some files not available in this compiler 
                       // but yes this program is right
class Node
{
    public:
    int data;
    Node *next;
};
int size = 0;
void insert(Node** head, int data)
{
    Node* new_node = new Node();
    
    new_node->data = data;
    new_node->next = *head;
    *head = new_node;
    size++;
}
void insertPosition(int pos, int data, Node** head)
{
    Node* new_node = new Node();
    new_node->data = data;
    new_node->next = NULL;
    if(pos < 1 || pos > size + 1) 
    {
    	    cout<<"Invalid\n";
	}
    else if(pos == 1)
	{
        new_node->next = *head; 
        *head = new_node;
        size++;
    }
    else 
    {
        Node* temp = *head;
        while(--pos > 1)
		{
            temp = temp->next;
        }
        new_node->next= temp->next;
        temp->next = new_node;
        size++;
    }
}
void display(Node* node)
{
    
    cout<<"Linked List : "<<endl;
    while(node!=NULL)
	{
        cout<<node->data<<",";
        node = node->next;
    }
    cout<<"\n";
}
int main()
{
    Node* head = NULL;
    insert(&head, 140);
    insert(&head, 120);
    insert(&head, 80);
    insert(&head, 60);
    insert(&head, 20);
    display(head);
    insertPosition(2, 40, &head);
    insertPosition(5, 100, &head);
    insertPosition(8, 160, &head);
    display(head); 
    return 0; 
}

----------------------------------------------------------------------------------------------------------------------------------------

#include<iostream>
#include<stdlib.h>
using namespace std;
struct node
{
	int data;
	struct node*link;
};
void count_of_node(struct node *head)
{
	int count=0;
	if(head==NULL)
	{
		cout<<"linked list is empty";
	}
	struct node *ptr=NULL;
	ptr=head;
	while(ptr!= NULL)
	{
		count++;
		ptr=ptr->link;
	}
	cout<<count<<endl;
}
void count_of_node1(struct node *tail)
{
	int count=0;
	if(tail==NULL)
	{
		cout<<"linked list is empty";
	}
	struct node *ptr=NULL;
	ptr=tail;
	while(ptr!= NULL)
	{
		count++;
		ptr=ptr->link;
	}
	cout<<count<<endl;
}
int main()
{
	struct node*head=NULL;
	head=(struct node*)malloc(sizeof(struct node));
	head->data=100;
	head->link=NULL;
	cout<<"The first entry of the linked list is :- "<<head->data<<endl;
	cout<<"-------------------------------------"<<endl;
	struct node*tail=NULL;
	tail=(struct node*)malloc(sizeof(struct node));
	tail->data=200;
	tail->link=NULL;
	cout<<"The second entry of the linked list is :- "<<tail->data<<endl;
	cout<<"--------------------------------------"<<endl;
	struct node*three=NULL;
	three=(struct node*)malloc(sizeof(struct node));
	three->data=300;
	three->link=NULL;
	cout<<"The third entry of the linked list is :- "<<three->data<<endl;
	cout<<"--------------------------------------"<<endl;
	count_of_node(head);
	count_of_node1(tail);
	return 0;
}




-----------------------------------------------------------------------------------------------------------------------------------------------

#include<iostream>
#include<stdlib.h>
using namespace std;
struct node
{
	int data;
	struct node *link;
};
struct node* add_beg(struct node* head,int d)
{
	struct node*ptr=NULL;
	ptr= (struct node*)malloc(sizeof(struct node));
	ptr->data=d;
	ptr->link=NULL;
	
	ptr->link= head;
	head=ptr;
	return head;
}
int main()
{
	struct node*head=NULL;
	head=(struct node*)malloc(sizeof(struct node));
	head->data=45;
	head->link=NULL;
	
	struct node*ptr=NULL;
	ptr=(struct node*)malloc(sizeof(struct node));
	ptr->data=98;
	ptr->link=NULL;
	
	head->link=ptr;
	
	int data=3;
	head=add_beg(head,data);
	ptr=head;
	while(ptr!=NULL)
	{
		cout<<ptr->data<<endl;
		ptr=ptr->link;
	}
	return 0;
}



---------------------------------------------------------------------------------------------------


#include <iostream>
#include<stdlib.h>   
#include<stdio.h>
using namespace std;      // program is right but not running in this compiler but it's running in the
                          // dev c++
struct node
{
    int data;
    struct node* next;
};

struct node* add_at_empty(int data)
{
    struct node* temp=NULL;
    temp=(struct node*)malloc(sizeof(struct node));
    temp->data=data;
    temp->next=temp;
    return temp;
};

struct node* add_at_beg(struct node* tail,int data)
{
    struct node* newP=NULL;
    newP=(struct node*)malloc(sizeof(struct node));
    newP->data=data;
    newP->next=tail->next;
    tail->next=newP;
    return tail;
};

struct node* add_at_end(struct node* tail,int data)
{
    struct node* newP=NULL;
    newP=(struct node*)malloc(sizeof(struct node));
    newP->data=data;
    newP->next=NULL;
    newP->next=tail->next;
    tail->next=newP;
    tail=tail->next;
    return tail;
};

struct node* after_pos(struct node* tail,int data,int pos)
{
    struct node* p=tail->next;
    struct node*newp=NULL;
    newp=(struct node*)malloc(sizeof(struct node));
    newp->data=data;
    newp->next=NULL;
    while(pos>1)
    {
        p=p->next;
        pos--;
    }
    newp->next=p->next;
    p->next=newp;
    if(p==tail)
    {
        tail=tail->next;
    }
    return tail;
};

struct node* create_list(struct node* tail)
{
    int i,n,data;
    cout<<"Enter number of nodes in the list"<<endl;
    cin>>n;
    if(n==0)
       return tail;
    else
    cout<<"Enter the element in 1:"<<endl;
    cin>>data;
    tail=add_at_empty(data);
    for(i=1;i<n;i++)
    {
        cout<<"enter the element "<<i+1<<endl;
        cin>>data;
        tail=add_at_end(tail,data);
    }
    return tail;
};


void print(struct node* tail)
{
    if(tail==NULL)
    cout<<"No nodes in the list"<<endl;
    else
    {
    struct node* P=tail->next;
    do
    {
     cout<<P->data<<endl;
     P=P->next;
    }while(P!=tail->next);
    }
}

int main()
{
    struct node*tail=NULL;
    tail=create_list(tail);
    print(tail);
    return 0;
}


----------------------------------------------------------------------------------------------------------------------------------

#include <iostream>
#include<stdlib.h>
using namespace std;
struct node
{
    int data;
    struct node* next;
};

struct node* add_at_empty(int data)
{
    struct node* temp=NULL;
    temp=(struct node*)malloc(sizeof(struct node));
    temp->data=data;
    temp->next=temp;
    return temp;
};

struct node* add_at_beg(struct node* tail,int data)
{
    struct node* newP=NULL;
    newP=(struct node*)malloc(sizeof(struct node));
    newP->data=data;
    newP->next=tail->next;
    tail->next=newP;
    return tail;
};

struct node* add_at_end(struct node* tail,int data)
{
    struct node* newP=NULL;
    newP=(struct node*)malloc(sizeof(struct node));
    newP->data=data;
    newP->next=NULL;
    newP->next=tail->next;
    tail->next=newP;
    tail=tail->next;
    return tail;
};

struct node* after_pos(struct node* tail,int data,int pos)
{
    struct node* p=tail->next;
    struct node*newp=NULL;
    newp=(struct node*)malloc(sizeof(struct node));
    newp->data=data;
    newp->next=NULL;
    while(pos>1)
    {
        p=p->next;
        pos--;
    }
    newp->next=p->next;
    p->next=newp;
    if(p==tail)
    {
        tail=tail->next;
    }
    return tail;
};

void print(struct node* tail)
{
    struct node* P=tail->next;
    do
    {
     cout<<P->data<<endl;
     P=P->next;
    }while(P!=tail->next);
}

int main()
{
    struct node*tail;
    tail=add_at_empty(100);
    tail=add_at_beg(tail,200);
    tail=add_at_end(tail,50);
    tail=add_at_end(tail,0);
    print(tail);
    cout<<"After adding at any position"<<endl;
    tail=after_pos(tail,10,2);
    print(tail);
    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------

#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
struct node
{
    struct node* prev;
    int data;
    struct node* next;
};
struct node* add_to_empty(struct node* head,int data)
{
	struct node* temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;  // for inserting the data in node using its node 
	head=temp;
	return head;
};

struct node* add_at_beg(struct node* head,int data)
{
	struct node*temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;   // for inserting the data in the begining of list
	temp->next=head;
	head->prev=temp;
	head=temp;
	return head;
};

struct node* add_at_end(struct node* head,int data)
{
	struct node*temp=NULL;
	struct node* tp;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;                        
	temp->data=data;                 // for inserting data at end
	temp->next=NULL;
	tp=head;
	while(tp->next !=NULL)
		tp=tp->next;
		tp->next=temp;
		temp->prev=tp;
	return head;
};
 
struct node* add_after_pos(struct node* head,int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    while(position!=1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=newP)
    {
        temp->next=newP;
        newP->prev=temp;
    }
    else
    {
        temp2=temp ->next;
        temp->next=newP;
        temp->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

struct node* add_before_pos(struct node* head, int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    int pos=position;
    while(pos>2)
    {
        temp=temp->next;
        pos--;
    }
    if(position==1)
    {
        head=add_at_beg(head,data);
    }
    else
    {
        temp2=temp->next;
        temp->next=newP;
        temp2->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};
struct node* del_first(struct node* head)
{
    struct node* temp=head;
    head=head->next;
    free(temp);
    temp=NULL;
    head->prev=NULL;
    return head;
};

struct node* del_last(struct node * head)
{
    struct node* temp=head;
    struct node* temp2;
    while(temp->next!=NULL)
         temp=temp->next;
    temp2=temp->prev;
    temp2->next=NULL;
    free(temp);
    return head;
};

struct node* del_inter(struct node * head , int position)
{
    struct node* temp=head;
    struct node* temp2=NULL;
    if(position==1)
    {
        head=del_first(head);
        return head;
    }
    while(position>1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=NULL)
    {
        head=del_last(head);
    }
    else
    {
        temp2=temp->prev;
        temp2->next=temp->next;
        temp->next->prev=temp2;
        free(temp);
        temp=NULL;
    }
    return head;
};

struct node* reverse(struct node* head)
{
  struct node* ptr1=head;
  struct node* ptr2=ptr1->next;
  ptr1->next=NULL;
  ptr1->prev=ptr2;
  while(ptr2!=NULL)
  {
      ptr2->prev=ptr2->next;
      ptr2->next=ptr1;
      ptr1=ptr2;
      ptr2=ptr2->prev;
  }
  head=ptr1;
  return head;
};

void print(struct node* head)
{
    struct node* ptr=head;
    while(ptr!=NULL)
    {
        cout<<ptr->data<<endl;
        ptr=ptr->next;
    }
    cout<<"\n";
}

int main()
{
    struct node* head=NULL;
    struct node *ptr;
    head=add_to_empty(head,34);
    head=add_at_end(head,45);
    head=add_at_end(head,9);
    print(head);
    cout<<"After reversing the list"<<endl;
    head=reverse(head);
    print(head);
    return 0;
}



----------------------------------------------------------------------------------------------------------------

#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
struct node
{
    struct node* prev;
    int data;
    struct node* next;
};
struct node* add_to_empty(struct node* head,int data)
{
	struct node* temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;  // for inserting the data in node using its node 
	head=temp;
	return head;
};

struct node* add_at_beg(struct node* head,int data)
{
	struct node*temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;   // for inserting the data in the begining of list
	temp->next=head;
	head->prev=temp;
	head=temp;
	return head;
};

struct node* add_at_end(struct node* head,int data)
{
	struct node*temp=NULL;
	struct node* tp;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;                        
	temp->data=data;                 // for inserting data at end
	temp->next=NULL;
	tp=head;
	while(tp->next !=NULL)
		tp=tp->next;
		tp->next=temp;
		temp->prev=tp;
	return head;
};
 
struct node* add_after_pos(struct node* head,int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    while(position!=1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=newP)
    {
        temp->next=newP;
        newP->prev=temp;
    }
    else
    {
        temp2=temp ->next;
        temp->next=newP;
        temp->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

struct node* add_before_pos(struct node* head, int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    int pos=position;
    while(pos>2)
    {
        temp=temp->next;
        pos--;
    }
    if(position==1)
    {
        head=add_at_beg(head,data);
    }
    else
    {
        temp2=temp->next;
        temp->next=newP;
        temp2->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};
struct node* del_first(struct node* head)
{
    struct node* temp=head;
    head=head->next;
    free(temp);
    temp=NULL;
    head->prev=NULL;
    return head;
};

struct node* del_last(struct node * head)
{
    struct node* temp=head;
    struct node* temp2;
    while(temp->next!=NULL)
         temp=temp->next;
    temp2=temp->prev;
    temp2->next=NULL;
    free(temp);
    return head;
};

struct node* del_inter(struct node * head , int position)
{
    struct node* temp=head;
    struct node* temp2=NULL;
    if(position==1)
    {
        head=del_first(head);
        return head;
    }
    while(position>1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=NULL)
    {
        head=del_last(head);
    }
    else
    {
        temp2=temp->prev;
        temp2->next=temp->next;
        temp->next->prev=temp2;
        free(temp);
        temp=NULL;
    }
    return head;
};

void print(struct node* head)
{
    struct node* ptr=head;
    while(ptr!=NULL)
    {
        cout<<ptr->data<<endl;
        ptr=ptr->next;
    }
    cout<<"\n";
}

int main()
{
    struct node* head=NULL;
    struct node *ptr;
    head=add_to_empty(head,34);
    head=add_at_end(head,45);
    head=add_at_end(head,9);
    cout<<"After deleting"<<endl;
    head=del_inter(head,1);
    print(head);
    return 0;
}

-------------------------------------------------------------------------------------------------------------------------------------

#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
struct node
{
    struct node* prev;
    int data;
    struct node* next;
};
struct node* add_to_empty(struct node* head,int data)
{
	struct node* temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;  // for inserting the data in node using its node 
	head=temp;
	return head;
};

struct node* add_at_beg(struct node* head,int data)
{
	struct node*temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;   // for inserting the data in the begining of list
	temp->next=head;
	head->prev=temp;
	head=temp;
	return head;
};

struct node* add_at_end(struct node* head,int data)
{
	struct node*temp=NULL;
	struct node* tp;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;                        
	temp->data=data;                 // for inserting data at end
	temp->next=NULL;
	tp=head;
	while(tp->next !=NULL)
		tp=tp->next;
		tp->next=temp;
		temp->prev=tp;
	return head;
};
 
struct node* add_after_pos(struct node* head,int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    while(position!=1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=newP)
    {
        temp->next=newP;
        newP->prev=temp;
    }
    else
    {
        temp2=temp ->next;
        temp->next=newP;
        temp->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

struct node* add_before_pos(struct node* head, int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    int pos=position;
    while(pos>2)
    {
        temp=temp->next;
        pos--;
    }
    if(position==1)
    {
        head=add_at_beg(head,data);
    }
    else
    {
        temp2=temp->next;
        temp->next=newP;
        temp2->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};
struct node* del_first(struct node* head)
{
    struct node* temp=head;
    head=head->next;
    free(temp);
    temp=NULL;
    head->prev=NULL;
    return head;
};

struct node* del_last(struct node * head)
{
    struct node* temp=head;
    struct node* temp2;
    while(temp->next!=NULL)
         temp=temp->next;
    temp2=temp->prev;
    temp2->next=NULL;
    free(temp);
    return head;
};


void print(struct node* head)
{
    struct node* ptr=head;
    while(ptr!=NULL)
    {
        cout<<ptr->data<<endl;
        ptr=ptr->next;
    }
    cout<<"\n";
}

int main()
{
    struct node* head=NULL;
    struct node *ptr;
    head=add_to_empty(head,34);
    head=add_at_end(head,45);
    head=add_at_end(head,9);
    cout<<"Before deleting node"<<endl;
    print(head);
    cout<<"After deleting ndoe"<<endl;
    head=del_first(head);
    print(head);
    cout<<"after deleting the last node"<<endl;
    head=del_last(head);
    print(head);
    return 0;
}


----------------------------------------------------------------------------------------------------------------------------
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
struct node
{
    struct node* prev;
    int data;
    struct node* next;
};
struct node* add_to_empty(struct node* head,int data)
{
	struct node* temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;  // for inserting the data in node using its node 
	head=temp;
	return head;
};

struct node* add_at_beg(struct node* head,int data)
{
	struct node*temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;   // for inserting the data in the begining of list
	temp->next=head;
	head->prev=temp;
	head=temp;
	return head;
};

struct node* add_at_end(struct node* head,int data)
{
	struct node*temp=NULL;
	struct node* tp;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;                        
	temp->data=data;                 // for inserting data at end
	temp->next=NULL;
	tp=head;
	while(tp->next !=NULL)
		tp=tp->next;
		tp->next=temp;
		temp->prev=tp;
	return head;
};
 
struct node* add_after_pos(struct node* head,int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    while(position!=1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=newP)
    {
        temp->next=newP;
        newP->prev=temp;
    }
    else
    {
        temp2=temp ->next;
        temp->next=newP;
        temp->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

struct node* add_before_pos(struct node* head, int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    int pos=position;
    while(pos>2)
    {
        temp=temp->next;
        pos--;
    }
    if(position==1)
    {
        head=add_at_beg(head,data);
    }
    else
    {
        temp2=temp->next;
        temp->next=newP;
        temp2->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};
struct node* del_first(struct node* head)
{
    struct node* temp=head;
    head=head->next;
    free(temp);
    temp=NULL;
    head->prev=NULL;
    return head;
};
void print(struct node* head)
{
    struct node* ptr=head;
    while(ptr!=NULL)
    {
        cout<<ptr->data<<endl;
        ptr=ptr->next;
    }
    cout<<"\n";
}

int main()
{
    struct node* head=NULL;
    struct node *ptr;
    head=add_to_empty(head,34);
    head=add_at_end(head,45);
    head=add_at_end(head,9);
    cout<<"Before deleting node"<<endl;
    print(head);
    cout<<"After deleting ndoe"<<endl;
    head=del_first(head);
    print(head);
    return 0;
}

------------------------------------------------------------------------------------------------------------------------------------------------------------
#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
struct node
{
    struct node* prev;
    int data;
    struct node* next;
};
struct node* add_to_empty(struct node* head,int data)
{
	struct node* temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;  // for inserting the data in node using its node 
	head=temp;
	return head;
};

struct node* add_at_beg(struct node* head,int data)
{
	struct node*temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;   // for inserting the data in the begining of list
	temp->next=head;
	head->prev=temp;
	head=temp;
	return head;
};

struct node* add_at_end(struct node* head,int data)
{
	struct node*temp=NULL;
	struct node* tp;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;                        
	temp->data=data;                 // for inserting data at end
	temp->next=NULL;
	tp=head;
	while(tp->next !=NULL)
		tp=tp->next;
		tp->next=temp;
		temp->prev=tp;
	return head;
};
 
struct node* add_after_pos(struct node* head,int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    while(position!=1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=newP)
    {
        temp->next=newP;
        newP->prev=temp;
    }
    else
    {
        temp2=temp ->next;
        temp->next=newP;
        temp->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

struct node* add_before_pos(struct node* head, int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    int pos=position;
    while(pos>2)
    {
        temp=temp->next;
        pos--;
    }
    if(position==1)
    {
        head=add_at_beg(head,data);
    }
    else
    {
        temp2=temp->next;
        temp->next=newP;
        temp2->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};
struct node* create_list(struct node* head)
{
    int n , data , i;
    cout<<"Enter the numbers of node"<<endl;
    cin>>n;
    if(n==0)
      return head;
     cout<<"Enter element for node 1"<<endl;
     cin>>data;
     head=add_to_empty(head,data);
     for(i=1;i<n;i++)
     {
         cout<<"Enter element for node "<<i+1;
         cin>>data;
         head=add_at_end(head,data);
     }
     return head;
};
int main()
{
    struct node* head=NULL;
    struct node * ptr;
    head=create_list(head);
    ptr=head;
    while(ptr!=NULL)
    {
        cout<<ptr->data;
        ptr=ptr->next;
    }
    return 0;
}


---------------------------------------------------------------------------------------------------------------------------------


#include<iostream>
#include<stdio.h>
#include<stdlib.h>
using namespace std;
struct node
{
	struct node* prev;
	int data;
	struct node* next;
};
struct node* add_to_empty(struct node* head,int data)
{
	struct node* temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;  // for inserting the data in node using its node 
	head=temp;
	return head;
};

struct node* add_at_beg(struct node* head,int data)
{
	struct node*temp=NULL;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;
	temp->data=data;
	temp->next=NULL;   // for inserting the data in the begining of list
	temp->next=head;
	head->prev=temp;
	head=temp;
	return head;
};

struct node* add_at_end(struct node* head,int data)
{
	struct node*temp=NULL;
	struct node* tp;
	temp=(struct node*)malloc(sizeof(struct node));
	temp->prev=NULL;                        
	temp->data=data;                 // for inserting data at end
	temp->next=NULL;
	tp=head;
	while(tp->next !=NULL)
		tp=tp->next;
		tp->next=temp;
		temp->prev=tp;
	return head;
};
 
struct node* add_after_pos(struct node* head,int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    while(position!=1)
    {
        temp=temp->next;
        position--;
    }
    if(temp->next=newP)
    {
        temp->next=newP;
        newP->prev=temp;
    }
    else
    {
        temp2=temp ->next;
        temp->next=newP;
        temp->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

struct node* add_before_pos(struct node* head, int data,int position)
{
    struct node* newP=NULL;
    struct node* temp=head;
    struct node* temp2=NULL;
    newP=add_to_empty(newP,data);
    int pos=position;
    while(pos>2)
    {
        temp=temp->next;
        pos--;
    }
    if(position==1)
    {
        head=add_at_beg(head,data);
    }
    else
    {
        temp2=temp->next;
        temp->next=newP;
        temp2->prev=newP;
        newP->next=temp2;
        newP->prev=temp;
    }
    return head;
};

int main()
{
  	struct node* head=NULL;
  	struct node* ptr;
  	int position=2;
    head=add_to_empty(head,200);
    head=add_at_beg(head,100);
    head=add_at_end(head,300);
    head=add_after_pos(head,150,position);
    head=add_before_pos(head,25,position);
    ptr=head;
    while(ptr!=NULL)
    {
     cout<<ptr->data<<endl;	
     ptr=ptr->next;
    }
    return 0;
}

----------------------------------------------------------------------------------------------------------


#include <iostream>
#include <map>
#include <queue>
using namespace std;

// Tree node structure
struct TreeNode
{
    char data;
    TreeNode* left;
    TreeNode* right;

    // Constructor
    TreeNode(char value)
    {
        data = value;
        left = NULL;
        right = NULL;
    }
};

// Custom comparison struct for priority queue
struct Compare
{
    bool operator()(TreeNode* a, TreeNode* b)
    {
        return a->data > b->data;
    }
};

// Function to build the Huffman tree
TreeNode* buildHuffmanTree(const map<char, int>& frequencies)
{
    // Create a priority queue (min heap) of tree nodes
    priority_queue<TreeNode*, vector<TreeNode*>, Compare> pq;

    // Create leaf nodes for each character and add them to the priority queue
    for (map<char, int>::const_iterator it = frequencies.begin(); it != frequencies.end(); ++it)
    {
        char character = it->first;
        int frequency = it->second;
        pq.push(new TreeNode(character));
    }

    // Build the Huffman tree by combining nodes from the priority queue
    while (pq.size() > 1)
    {
        TreeNode* left = pq.top();
        pq.pop();

        TreeNode* right = pq.top();
        pq.pop();

        TreeNode* newNode = new TreeNode('#');
        newNode->left = left;
        newNode->right = right;
        pq.push(newNode);
    }

    // Return the root of the Huffman tree
    return pq.top();
}

// Function to generate Huffman codes for each character
void generateHuffmanCodes(TreeNode* root, string code, map<char, string>& codes)
{
    if (root == NULL)
        return;

    if (root->left == NULL && root->right == NULL)
    {
        codes[root->data] = code;
        return;
    }

    generateHuffmanCodes(root->left, code + '0', codes);
    generateHuffmanCodes(root->right, code + '1', codes);
}

// Function to compress a string using Huffman codes
string compressString(const string& input, const map<char, string>& codes)
{
    string compressedString;

    // Replace each character with its corresponding Huffman code
    for (size_t i = 0; i < input.length(); ++i)
    {
        compressedString += codes.find(input[i])->second;
    }

    return compressedString;
}

// Function to decompress a string using Huffman codes
string decompressString(const string& compressedString, TreeNode* root)
{
    string decompressedString;

    TreeNode* currentNode = root;
    for (size_t i = 0; i < compressedString.length(); ++i)
    {
        if (compressedString[i] == '0')
        {
            currentNode = currentNode->left;
        }
        else if (compressedString[i] == '1')
        {
            currentNode = currentNode->right;
        }

        if (currentNode->left == NULL && currentNode->right == NULL)
        {
            decompressedString += currentNode->data;
            currentNode = root;
        }
    }

    return decompressedString;
}

int main()
{
    string input = "Huffman algorithm example";

    // Step 1: Count the frequency of each character in the input string
    map<char, int> frequencies;
    for (size_t i = 0; i < input.length(); ++i)
    {
        char c = input[i];
        frequencies[c]++;
    }

    // Step 2: Build the Huffman tree
    TreeNode* root = buildHuffmanTree(frequencies);

    // Step 3: Generate Huffman codes for each character
    map<char, string> codes;
    generateHuffmanCodes(root, "", codes);

    // Step 4: Compress the input string using Huffman codes
    string compressedString = compressString(input, codes);

    // Step 5: Decompress the compressed string using Huffman codes
    string decompressedString = decompressString(compressedString, root);

    // Output
    cout << "Input string: " << input << endl;
    cout << "Compressed string: " << compressedString << endl;
    cout << "Decompressed string: " << decompressedString << endl;

    return 0;
}

_________________________________________________________________________________________________________________________________________________________________________________________________________________________



										// QUEUE USING LINKED LIST
#include<iostream>
#include<stdlib.h>
using namespace std;

// FOR IMPLEMENTING STRUCTURE 
typedef struct node
{
	int data;
	struct node* next;
}node1;

node1* front = NULL;
node1* rear = NULL;

// FOR ENTERING THE DATA IN THE QUEUE
void enqueue()
{
	node1* temp;
	temp = (struct node*)malloc(sizeof(struct node));
	cout << "Enter data: ";
	cin >> temp->data;
	if (front == NULL)
	{
		temp->next = NULL;
		front = temp;
		rear = temp;
	}
	else
	{
		rear->next = temp;
		rear = temp;
		rear->next = NULL;
	}
}

// FOR DELETING THE DATA FROM QUEUE
void dequeue()
{
	node1* temp;
	struct node* ptr = NULL;
	ptr = front;
	front = front->next;
	cout << "Deleted element is " << ptr->data << endl;
	free(ptr);
}

// FOR DISPLAYING THE DATA FROM THE QUEUE
void display()
{
	node1* ptr;
	if (front == NULL)
	{
		cout << "Queue is empty" << endl;
	}
	else
	{
		for (ptr = front; ptr != NULL; ptr = ptr->next)
		{
			cout << ptr->data << " ";
		}
		cout << endl;
	}
}

int main()
{
	int ch;
	while (1)
	{
		cout << "1. Enqueue" << endl;
		cout << "2. Dequeue" << endl;
		cout << "3. Display" << endl;
		cout << "4. Exit" << endl;
		cout << "Enter your choice: ";
		cin >> ch;

		switch (ch)
		{
		case 1:
			enqueue();
			break;

		case 2:
			dequeue();
			break;

		case 3:
			display();
			break;

		case 4:
			exit(1);
			break;

		default:
			cout << "Entered choice is invalid" << endl;
		}
	}
	return 0;
}

__________________________________________________________________________________________________________________________________________________________________________________________________________________


								// STACK IMPLEMENTING USING THE LINKED LIST
#include <iostream>
#include<stdlib.h>
using namespace std;
// CREATING STRUCTURE OF THE LINKED LIST
struct node
{
 int data;
 struct node*link;
}*top=NULL;

// TO CHECK WHETHER IT IS EMPTY OR NOT
int isEmpty()
{
	if(top==NULL)
	{
		return 1;
	}
	else
	{
		return 0;
	}
}

// FOR ENTERING DATA IN THE STACK 
void push(int data)
{
    struct node*newnode;
    newnode=(struct node*)malloc(sizeof(struct node));
    if(newnode==NULL)
    {
        cout<<"Stack overflow\n";
        exit(1);
    }
    newnode->data=data;
    newnode->link=NULL;
    
    newnode->link=top;
    top=newnode;
}

// FOR DELETING THE DATA FROM STACK
int pop()
{
	struct node*temp;
	int val;
	if(isEmpty())
	{
		cout<<"Stack underflow"<<endl;
		exit(1);
	}
	temp=top;
	val=temp->data;
	top=top->link;
	free(temp);
	temp=NULL;
	return val;
}

// FOR RETURNING THE DATA USER WANT TO SEE
int peek()
{
	if(isEmpty())
	{
		cout<<"Stack is underflow"<<endl;
		exit(1);
	}
	return top->data;
}
void print()
{
    struct node*temp;
    temp=top;
    cout<<"Element of the stack are-->"<<endl;
    while(temp)
    {
        cout<<temp->data<<endl;
        temp=temp->link;
    }
    cout<<"\n";
}

// MAIN FUNCTION 
int main()
{
    int choice;
    int data;
    while(1)
    {
       
        cout<<"1.Push"<<endl;
        cout<<"2.Pop"<<endl;
        cout<<"3.Print top element"<<endl;
        cout<<"4.Print all element"<<endl;
        cout<<"5.Quit"<<endl;
        cout<<"Enter your choice"<<endl;
        cin>>choice;
        
        switch(choice)
        {
            case 1 : cout<<"Enter element to push in the stack"<<endl;
            cin>>data;
            push(data);
            break;
            
            case 2: data=pop();
                    cout<<"Deleted element is "<<data<<endl;
            break;
            
            case 3:cout<<"Top element of the list "<<peek()<<endl;
            break;
            
            case 4: cout<<"All element are"<<endl;
                    print();
            break;
            
            case 5: exit(1);
            
            default:
                cout<<"Wrong choice"<<endl;
            break;
        }
    }
    return 0;
}

_________________________________________________________________________________________________________________________________________________________________________________________________________

#include<iostream>
using namespace std;
# define n 100
class stack
{
	private:
		int * arr;
		int top;
	public:
		stack()
		{
			arr=new int[n];
			top=-1;
		}
		void push(int x)
		{
			if(top==n-1)
			{
				cout<<"Stack overflow\n";
				return ;
			}
			top++;
			arr[top]=x;
		}
		void pop()
		{
			if(top==-1)
			{
				cout<<"no elemen to pop\n";
				return ;
			}
			top--;
		}
		int Top()
		{
			if(top==-1)
			{
				cout<<"no elemen to pop\n";
				return -1 ;
			}
			return arr[top];
		}
		
		bool empty()
		{
			return top==-1;
		}
};
void displayStack(stack s)       // this will display the element of stack in the order 
{
    if (s.empty())
    {
        cout << "Stack is empty." << endl;
        return;
    }

    cout << "Elements of the stack: "<<endl;
    while (!s.empty())
    {
        cout << s.Top()<<endl;
        s.pop();
    }
    cout << endl;
}
int main()
{
	stack s1;
	s1.push(100);
	s1.push(200);
	s1.push(300);
	cout<<s1.Top()<<endl;
    displayStack(s1);
	return 0;
}
____________________________________________________________________________________________________________________________________________________________________________________________________________







